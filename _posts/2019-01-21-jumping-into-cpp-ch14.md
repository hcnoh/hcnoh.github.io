---
layout: post
use_math: true
title: "Jumping Into C++ 스터디 챕터 14"
date: 2019-01-21 21:04:26
tagline: "Jumping Into C++ 스터디 내용 간단하게 정리"
categories:
- Jumping Into C++ 스터디
tags:
- c++
image: /thumbnail-mobile.png
author: "Hyungcheol Noh"
permalink: /2019-01-21-jumping-into-cpp-ch14
---

이번 포스팅은 다음의 링크를 참고하여 작성되었다.
- [링크1](https://dsnight.tistory.com/50)

# 동적 메모리 할당
동적 할당 이란?
- 프로그램이 실행되고 있는 동안에도 메모리를 필요한 만큼 요청하는 것을 의미
- 즉, `런타임`에 메모리 할당량이 결정되기를 원하는 경우에 사용
- `힙 영역`에 할당됨

## C언어의 메모리 구조
데이터 영역, 스택 영역, 힙 영역으로 구성

![](/assets/img/2019-01-21-jumping-into-cpp-ch14/01.png)

(출처: [https://dsnight.tistory.com/50](https://dsnight.tistory.com/50))

### 데이터(Data) 영역
- `전역 변수`, `Static 변수`가 저장
- 프로그램 시작시에 메모리에 할당, 종료시에 메모리에서 소멸

### 스택(Stack) 영역
- 함수 호출시에 생성되는 `지역 변수` 및 `매개 변수`가 저장
- 함수 호출이 완료되면 메모리에서 소멸

```c++
#include <stdio.h>

void fct1(int);
void fct2(int);

int a = 10;	// 데이터 영역에 할당
int b = 20;	// 데이터 영역에 할당

int main() {
    int i = 100;	// 지역변수 i가 스택 영역에 할당
    fct1(i);
    fct2(i);
    return 0;
}

void fct1(int c) {
    int d = 30;	    // 매개변수 c와 지역변수 d가 스택영역에 할당
}

void fct2(int e) {
    int f = 40;	    // 매개변수 e와 지역변수 f가 스택영역에 할당
}
```

![](/assets/img/2019-01-21-jumping-into-cpp-ch14/02.png)

(출처: [https://dsnight.tistory.com/50](https://dsnight.tistory.com/50))

### 힙(Heap) 영역
- 필요시에 동적으로 메모리를 할당할 때 사용
- `런타임`때 유용하게 사용됨

### 힙 영역의 필요성?
메모리 구조상 배열의 길이는 항상 상수여야 함

```c++
int main() {
    // 정상적인 배열선언
    int arr[10];
    
    // 비 정상적인 배열선언
    int i = 0;
    scanf("%d", &i);
    int arr[i];
    return 0;
}
```

다음과 같은 방법 역시 비정상적인 방법... `컴파일 에러`가 발생!

```c++
int main() {
    int i = 10;
    int arr[i];
    return 0;
}
```

그 이유?
- `컴파일`을 하는 동안에는 `i`가 4바이트라는 것만 알 수 있음
- `i`가 10으로 할당된다는 사실은 `런타임`에 결정됨!

즉, 사용자의 요구에 맞게 메모리를 할당하기 위해서는 `런타임`에 메모리를 결정해야 함!

## 동적 할당 방법
`포인터`에 동적 할당된 메모리를 대입 가능!

`new` 키워드를 사용하여 포인터에 동적 할당된 메모리 대입:

```c++
int *p_int = new int
```

여기에서 `new` 뒤에있는 `int`는 `int`의 크기인 4바이트 만큼의 메모리를 리턴하라는 의미!

즉, `p_int`에는 4바이트만큼의 힙 영역의 메모리가 동적으로 할당됨

## 메모리 반환
동적 할당 이후에는 꼭 메모리를 반환해야 함! 만약 그렇게하지 않으면 메모리 부족 현상이 발생...

메모리를 반환한 이후에는 `NULL`을 가리키도록 리셋하는 것이 좋음

```c++
delete p_int;
p_int = NULL;
```

## 레퍼런스에 대한 동적 할당?
다음과 같이 레퍼런스에 동적으로 할당한 메모리를 저장하면 안됨!

```c++
int &val = *(new int);
```

이유?
- 레퍼런스는 변수에 이름 하나를 더 제공하는 것
- 동적으로 할당된 메모리에 저장 공간을 제공하는 것이 아님

## 포인터와 배열
포인터는 배열처럼 취급될 수 있음!
- 포인터는 메모리 주소를 저장
- 따라서, 배열의 첫 번째 요소에 해당하는 주소가 포인터에 저장

배열을 포인터에 대입 가능:

```c++
int numbers[8];
int *p_numbers = numbers;

for (int i=0; i<8; ++i {
    p_numbers[i] = i;
}
```

즉, 배열은:
- 포인터는 아님
- 포인터에 대입 가능

컴파일러의 배열 -> 포인터 변환 방식:
- 배열의 첫 번째 요소를 포인터가 가리키도록 함

## 메모리의 배열로 동적 할당
`포인터`에는 동적 할당된 메모리 대입 가능!

또한 `포인터`에는 배열을 대입하는 것도 가능!

따라서 `메모리의 배열`을 동적으로 할당하고 이 메모리를 포인터에 대입 가능:

```c++
int *p_numbers = new int[8];
```

메모리의 배열을 반환:

```c++
delete[] p_numbers;
```

## 포인터 연산

간편 문법(Syntatic sugar):
- 배열의 대괄호 연산자같이 간결해진 특별한 문법을 의미

배열의 연산은 메모리 블록을 사용해서 값이 들어갈 곳의 오프셋의 정확히 알고 있음:

```c++
int x[10];

// 아래의 두 식은 같은 의미
x[3] = 120;
*(x+3) = 120;
```

여기서 `x+3`의 의미는 `x + 3*sizeof(int)`

즉, 포인터 연산은 항상 메모리의 슬롯을 더하는 것임...

포인터를 수처럼 다루는 것이 아님!

포인터 연산은 복잡하니까 배열 문법을 사용하는 것이 좋음...

## 2차원 배열
2차원 배열이 인수로 전달되는 함수: 반드시 2차원 요소의 크기를 제공해야 함!

```python
int sumTwoDArray(int array[][4]);
```

이유? 올바른 포인터 연산을 수행하기 위해서!

실제 메모리 상에 3X3 메모리 배열이 배치되는 모습:

```c++
[0][0][0][1][1][1][2][2][2]
```

즉, `array[2][1]`은 다음의 포인터 연산으로 전환될 수 있음

```c++
*(array + 2 * <배열의 너비> + 1)
```

이런 식으로 2차원 배열은 너비를 직접 입력해야 한다는 단점!

마음대로 너비를 정해서 2차원 배열을 동적으로 할당하려면 포인터의 포인터가 필요함!

## 포인터의 포인터
포인터의 포인터 선언:

```c++
int *p_y;
int **p_p_x;
p_p_x = &p_y;
```

선언된 포인터의 포인터에 동적 할당된 메모리 대입:
```c++
int *p_y;
int **p_p_x;
p_p_x = &p_y;

*p_p_x = new int;
```

틱택토 보드를 저장하기 위한 포인터의 포인터:
```c++
int **p_p_tictactoe;
p_p_tictactoe = new int*[3];        // 사이즈가 3인 int 포인터들의 배열로 동적 할당하여 대입
                                    // new int*[]은 int 포인터들의 배열로 동적 할당하여 리턴한다는 의미의 문법

for (int i=0; i<3; i++) {
    p_p_tictactoe[i] = new int[3];  // 각각의 int 포인터들마다 사이즈가 3인 int 배열로 동적 할당하여 대입
}

for (int i=0; i<3; i++) {
    for (int j=0; j<3; j++) {
        p_p_tictactoe[i][j] = 0;    // 모든 보드의 값들을 0으로 초기화
    }
}

for (int i=0; i<3; i++) {
    delete[] p_p_tictactoe[i];
}
delete[] p_p_tictactoe;             // 모든 메모리 반환
```

## 포인터의 포인터와 2차원 배열
주의: 2차원 배열의 메모리 배치 방식은 포인터의 포인터가 2차원 배열을 담기 위한 메모리 배치 방식과 다름!

배열은 포인터에 대입 가능:

```c++
int x[8];
int *y = x;
```

하지만, 2차원 배열은 포인터의 포인터로는 대입 불가능:

```c++
int x[8][8];
int **y = x;    // 컴파일 에러 발생
```
